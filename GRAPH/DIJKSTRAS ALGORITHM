import java.util.*;

class Solution {
    public class Edge {
        int dt;
        int wt;
        public Edge(int d, int w){
            this.dt = d;
            this.wt = w;
        }
    }

    public void createGraph(ArrayList<Edge> graph[], int[][] a, int V){
        for(int i=0;i<V;i++){
            graph[i] = new ArrayList<>();
        }
        for(int i=0;i<a.length;i++){
            int u = a[i][0];
            int v = a[i][1];
            int w = a[i][2];
            graph[v].add(new Edge(u, w)); // reverse edge
        }
    }

    public class Pair implements Comparable<Pair> {
        int node;
        int dist;
        public Pair(int n, int d){
            this.node = n;
            this.dist = d;
        }
        @Override
        public int compareTo(Pair p2){
            return this.dist - p2.dist;
        }
    }

    public void dijkstras(ArrayList<Edge> graph[], int k, int V, int[] dest){
        PriorityQueue<Pair> pq = new PriorityQueue<>();
        Arrays.fill(dest, Integer.MAX_VALUE);
        dest[k] = 0;
        boolean[] vis = new boolean[V];
        pq.add(new Pair(k,0));

        while(!pq.isEmpty()){
            Pair cur = pq.remove();
            if(!vis[cur.node]){
                vis[cur.node] = true;
                for(Edge e : graph[cur.node]){
                    int v = e.dt;
                    int w = e.wt;
                    if(dest[cur.node] + w < dest[v]){
                        dest[v] = dest[cur.node] + w;
                        pq.add(new Pair(v, dest[v]));
                    }
                }
            }
        }
    }

    public int[] dijkstra(int V, int[][] edges, int src) {
        ArrayList<Edge> graph[] = new ArrayList[V];
        createGraph(graph, edges, V);
        int[] dest = new int[V];
        dijkstras(graph, src, V, dest);

        // Optional: Convert unreachable nodes (Integer.MAX_VALUE) to -1
        for(int i=0;i<V;i++){
            if(dest[i]==Integer.MAX_VALUE) dest[i] = -1;
        }
        return dest;
    }
}
